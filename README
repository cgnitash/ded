

ded (Digital Evolutionary Dynamics) is a framework that supports research in evolutionary theory. More precisely, ded aims to support all such research, and to do so in a way that is simultaneously easy for a researcher new to the field to use, ans also provides more seasoned researchers freedom in implementation, both in terms of design and performance. The rationale behind the design of ded is expanded below.

There are currently many different frameworks that support such research. However, each framework is suited to the research interests of the group that implemented the framework. A diversity of frameworks that ask similar questions is valuable; mistakes in a particular implementation can be spotted more readily, at least if they produce results that are in contrast with the published literature; an implementation is free to focus on making specific subsets of evolutionary theory easier to investigate; individuals working with a particular implementation are often aware of their internals, thereby accelerating the pace at which their research can be accomplished. 

There are however, some downsides to this diversity; since less care is given to interoperability between different frameworks, highly similar results from multiple implementations are not easily comparable, and is practically often achievable only through the concerted efforts of all research groups involved. This unfortunately leads to many results not being verified. Every framework, obviously has its own style, quirks, idiosyncracies. Learning one can take significant amount of effort, and it is unreasonable to learn more than a handful. For someone who has a question about a particular result, answering it requires a fair amount of effort, and usually the direct help of the group involved in the generation of the original results. This is not sustainable for individual researchers, whether new to the field, or for that matter, the reviewers of the results; questions that are trivially answerable by the researcher, are often beyond the capabilities of the reviewer to answer.

There are perhaps valid reasons for this; it is not worth the investment on a reseracher's part to learn a foriegn framework, only to verify previously published results, a vast majority of which are likely correct. Additionally, making it easier for others to extend one's own work, makes it easier to be scooped in publications, which is a valid concern for many researchers, given the currently dominant incentive structures.

ded makes the assumption that the benefits of using a common framework outweighs the negative effects. This effort then, has some difficult, and at first glance, contradictory requirements to be satisfied in order to be considered a success.

Firstly, all questions about evolutionary theory should be askable easily. All is not necessarily used in the literal sense here, but to a first approximation that is a requirement.

Secondly, if the various components already in the framework, are insufficient to ask a particular question, then implementing that functionality should be easy, and not prematurely pessimize the implementation. By easy I mean, if the needed functionality satisfies any evolutionary concept, then there should be a straightforward way to add it. The simplest way of adding functionality need not be particularly high performing, so long as the researcher is able to optimise their implementation to run with native efficiency. 

Thirdly, there need to be constraints on how the question is asked; e.g. a question is valid only if it is unambigious. These are all constraints that we want anyway. Additionally, the same question can be asked in a way that appears to be syntactically different, but actually is the same, and generates the same results. ded needs to ensure that these questions are both considered to be the same, and refer to the same simulation. 

ded is not aiming to be a general purpose entity-component-system, and so there are several concepts that are defined based upon the needs of evolutionary research.

Signal: this is just a piece of information, or data. This is typically the method used by different components in the framework to interact with each other. e.g. numbers, images, light rays, sounds, etc are all things that should be implemented as Signal.

Substrate: This is something that has behaviour, and can be affected by things around it, and can affect things in turn. Frameworks variously refer to instantiations of this concept as, agent, entity, substrate, organism, etc. Typically, substrates are the primary concept under investigation, since that is usually the concept undergoing selection, and as a result, where the unknown behaviours arise from, and why simulations are needed in the first place.
 Formally, a component can, and should be implemented as a Substrate, if reasonable semantics can be provided for the following concepts   
 tick: this is the smallest discrete unit of time that this substrate can be asked to do its thing. i.e. every time tick is called on a substrate, the substrate experiences 1 unit time of its life. Within that unit of time, a substrate can obviously do arbitrarily complex computations that take arbitrary amounts of real time.
 input: a substrate must define what sorts of signals it can recieve from the outside. This set can be empty (not very useful), or infinite (more useful, if it's reasonable to define a Substrate that can respond to any Signal), or any finite set of signals. e.g. a Substrate might be able to distinguish between exactly 4 types of input, namely, a sound wave,  a set of smells, and 2 different images. Note that multiple signals of the identical type can be distinguished.
 output: same as inputs, except obviously, that these are signals that the Substrate sends to the outside.
 mutate: the substrate can by modified in some way. Strictly speaking, this is not necessary, but the resulting evolutionary dynamics are unsurprisingly uninteresting.
There are other concepts that a Substrate might satisfy, that are not necessary, but mean that they can be used in additional ways. Not providing these definitions means an implicit no-op on these calls.

Encoding: this is a piece of data from which Substrates can be constructed. Frameworks variously refer to instantiations of this concept as, genomes, genes, etc. For many research questions, this is the primary unit whose properties are being studied. A component can, and should be implemented as an Encoding if it satisfies the following concepts
 pointMutate: individual sites can be mutated
 copyChunk: chunks of sites can be copied to other locations
 delChunk:  chunks of sites can be deleted from various locations
 etc.
There are other concepts that an Encoding might satisfy, that are not necessary, but mean that they can be used in additional ways. Not providing these definitions means an implicit no-op on these calls.

Population: This is a collection of Substrates.  Frameworks variously refer to instantiations of this concept as, population, species, etc. Implementations of this concept are often used to describe the collective behaviour of Substrates, and is the unit that allows for Substrates to have different properties, such as fitness, etc.  A component can, and should be implemented as a Population if it satisfies the following concepts
 size: this simply defines the number of Substrates that a population contains.
 getAsVector: this returns the collection of Substrates as a vector. Additional structural information can be provided, either by defining certain functionality, or by adding to Signals to the Substrates that contain that information.
 merge: A Population must be able to take in another population (containing the same kinds of Substrates), and merge that into its own collection of Substrates. 
 snapShot: store the current population to disk.
There are other optional functionalities that may be provided, typically to handle more advanced functionality such as lineage tracking, etc.

Process: This is something that guides interactions between the various Substrates in a Population.  Frameworks variously refer to instantiations of this concept as, environment, world, fitness-function, optimiser, etc. Implementations of this concept are often used to describe , and is the unit that allows for Substrates to have different properties, such as fitness, etc.  A component can, and should be implemented as a Population if it satisfies the following concepts


